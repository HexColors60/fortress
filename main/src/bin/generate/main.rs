
#[macro_use]
extern crate structopt_derive;
extern crate structopt;

extern crate world;
extern crate generate;

use std::io::stdout;
use structopt::StructOpt;

use generate::generate::new_map;
use generate::generate::MapOptions;
use world::print;
use util::states::OnOff;

///
/// The structure of the commands.
///
/// A large amount of this is generated by StructOpt.
/// See that project for how to write large amounts of this.
///
/// The gist however is that we make a struct that will hold
/// all of our arguments. Commands are then parsed, and then
/// turned into this struct.
///
#[derive(StructOpt, Debug)]
#[structopt(name = "Map Generator", about = "Generates maps.")]
struct Args {

    #[structopt(short = "s", long = "seed", help = "Seed for the random generator.")]
    pub seed : Option<usize>,

    #[structopt(short = "w", default_value="50", long = "width", help = "Set width for the map.")]
    pub width : u32,

    #[structopt(short = "h", default_value="50", long = "height", help = "Set height for the map.")]
    pub height : u32,

    #[structopt(subcommand)]
    pub colour : Option<ArgsColour>,

}

///
/// For turning colour on or off.
///
#[derive(StructOpt, Debug)]
#[derive(PartialEq, Eq)]
#[allow(non_camel_case_types)]
enum ArgsColour {
    colour,
    no_colour,
}

fn main() {
    let args = Args::from_args();

    let map = new_map( MapOptions {
        width : args.width,
        height : args.height,
        seed : args.seed,
    });

    let mut out = stdout();
    out.lock();

    let colour = if args.colour == Some(ArgsColour::colour) { util::states::OnOff::On } else { util::states::OnOff };
    print::print_map( colour, & map, &mut out );
}

